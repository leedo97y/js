1. This
함수의 this 키워드는 다른 언어와 조금 다르게동작한다. 또한 엄격모드와 비엄격모드에서 일부 차이가 있다. 

대부분의 경우 this의 값은 함수를 호출한 방법에 의해 결정
실행중에는 할당으로 설정할 수 없고, 함수를 호출할 때마다 다를 수도 있다. 
ES5는 함수를 어떻게 호출했는지 상관하지 않고 this 값을 설정할 수 있는 bind 메서드를 도입했다.
또한, ES2015는 스스로의 this 바인딩을 제공하지 않는 화살표 함수를 추가했다. 
--> 스코프와도 이어진다. / 관계가 있다.


2. 상황별로 동작하는 방법 다름 (전역 공간)
1) Node.JS -> global 속성 : alert 존재 X -> process.env가 있음
2) 브라우저 -> 전역 공간에서의 this가 window를 바라봄 : alert 존재 O -> process.env가 없음
=> 같은 this, 같은 전역 공간에서도 다름


3. 함수에서의 this (지역 공간)
--> 전역 공간을 가리킨다.(바라본다.)


4. 객체에서의 this (지역 공간)
메서드를 가지고 테스트 = 함수랑 다름 
--> 호출되는 객체의 대상을 바라봄
----> 만약에 2중으로 구성된 문이 있다면 가장 안쪽에 있는 대상의 this가 불림
(최대한 간결하게 만드는 것이 좋다.)


5. 명시적인 바인딩
- 사용상황에 따른 호출 -> 사용자가 생각하는 것과 다를 수 있음 (---> 암시적인 바인딩)

5-1. function.prototype.apply()
내장된 메서드 -> 테스트는 const로 하는 것이 좋다. (선언시)
= var는 누구나 수정할 수 있는 값이기 때문에 불안정하고, 불온전하다
---> apply는 배열을 인자로 받음 - 배열을 이용할 때 apply 쓰면 됨
arguments[] - 로 쓸 수 있음

5-2. function.prototype.bind()
apply가 쓰기 좀 그럴 때 쉽게 쓸 수 있음 
묶여있는 것임 -> this가 완전히 고정되어있음 


5-3. function.prototype.call()
첫번째 인자 : 명시적으로 조작하고 싶은 인자
두번째 인자 : 원본의 함수가 받는 인자


==> this를 완전히 묶어놓고 사용 가능 (call, apply, bind)
